<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ThermalSim KiCad Plugin - Umfassender Review-Report</title>
  <style>
    :root {
      --primary: #2563eb;
      --primary-dark: #1d4ed8;
      --bg: #f8fafc;
      --card-bg: #ffffff;
      --text: #1e293b;
      --text-light: #64748b;
      --border: #e2e8f0;
      --code-bg: #f1f5f9;
      --success: #22c55e;
      --warning: #f59e0b;
      --error: #ef4444;
    }
    * { box-sizing: border-box; }
    body {
      font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
      line-height: 1.7;
      color: var(--text);
      background: var(--bg);
      margin: 0;
      padding: 0;
    }
    .container {
      max-width: 900px;
      margin: 0 auto;
      padding: 2rem;
    }
    header {
      background: linear-gradient(135deg, var(--primary), var(--primary-dark));
      color: white;
      padding: 3rem 2rem;
      text-align: center;
    }
    header h1 {
      margin: 0 0 0.5rem 0;
      font-size: 2.5rem;
      font-weight: 700;
    }
    header p {
      margin: 0;
      opacity: 0.9;
      font-size: 1.1rem;
    }
    nav {
      background: var(--card-bg);
      border-bottom: 1px solid var(--border);
      padding: 1rem 2rem;
      position: sticky;
      top: 0;
      z-index: 100;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    nav ul {
      list-style: none;
      margin: 0;
      padding: 0;
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem 1.5rem;
      justify-content: center;
    }
    nav a {
      color: var(--text);
      text-decoration: none;
      font-size: 0.9rem;
      padding: 0.25rem 0;
      border-bottom: 2px solid transparent;
      transition: all 0.2s;
    }
    nav a:hover {
      color: var(--primary);
      border-bottom-color: var(--primary);
    }
    section {
      background: var(--card-bg);
      border-radius: 12px;
      padding: 2rem;
      margin: 2rem 0;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    h2 {
      color: var(--primary);
      font-size: 1.75rem;
      margin: 0 0 1.5rem 0;
      padding-bottom: 0.75rem;
      border-bottom: 2px solid var(--border);
    }
    h3 {
      color: var(--text);
      font-size: 1.25rem;
      margin: 1.5rem 0 1rem 0;
    }
    h4 {
      color: var(--text-light);
      font-size: 1rem;
      margin: 1.25rem 0 0.75rem 0;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    p { margin: 0 0 1rem 0; }
    ul, ol {
      margin: 0 0 1rem 0;
      padding-left: 1.5rem;
    }
    li { margin-bottom: 0.5rem; }
    code {
      background: var(--code-bg);
      padding: 0.2em 0.4em;
      border-radius: 4px;
      font-family: 'Cascadia Code', 'Fira Code', Consolas, monospace;
      font-size: 0.9em;
    }
    pre {
      background: var(--code-bg);
      padding: 1.25rem;
      border-radius: 8px;
      overflow-x: auto;
      font-family: 'Cascadia Code', 'Fira Code', Consolas, monospace;
      font-size: 0.85rem;
      line-height: 1.5;
      margin: 1rem 0;
      border: 1px solid var(--border);
    }
    pre code {
      background: none;
      padding: 0;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin: 1rem 0;
      font-size: 0.95rem;
    }
    th, td {
      padding: 0.75rem 1rem;
      text-align: left;
      border-bottom: 1px solid var(--border);
    }
    th {
      background: var(--code-bg);
      font-weight: 600;
      color: var(--text);
    }
    tr:hover td { background: var(--bg); }
    .badge {
      display: inline-block;
      padding: 0.25rem 0.75rem;
      border-radius: 9999px;
      font-size: 0.8rem;
      font-weight: 500;
    }
    .badge-success { background: #dcfce7; color: #166534; }
    .badge-warning { background: #fef3c7; color: #92400e; }
    .badge-error { background: #fee2e2; color: #991b1b; }
    .badge-info { background: #dbeafe; color: #1e40af; }
    .highlight-box {
      background: linear-gradient(135deg, #eff6ff, #dbeafe);
      border-left: 4px solid var(--primary);
      padding: 1rem 1.25rem;
      border-radius: 0 8px 8px 0;
      margin: 1rem 0;
    }
    .warning-box {
      background: linear-gradient(135deg, #fffbeb, #fef3c7);
      border-left: 4px solid var(--warning);
      padding: 1rem 1.25rem;
      border-radius: 0 8px 8px 0;
      margin: 1rem 0;
    }
    .equation {
      background: var(--code-bg);
      padding: 1.5rem;
      border-radius: 8px;
      text-align: center;
      margin: 1.5rem 0;
      font-family: 'Times New Roman', serif;
      font-size: 1.2rem;
      border: 1px solid var(--border);
    }
    .file-ref {
      font-family: 'Cascadia Code', monospace;
      font-size: 0.85rem;
      color: var(--primary);
    }
    .grid-2 {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 1.5rem;
    }
    .metric-card {
      background: var(--bg);
      padding: 1.25rem;
      border-radius: 8px;
      border: 1px solid var(--border);
    }
    .metric-card h4 {
      margin: 0 0 0.5rem 0;
      font-size: 0.9rem;
    }
    .metric-value {
      font-size: 2rem;
      font-weight: 700;
      color: var(--primary);
    }
    .ascii-diagram {
      font-family: 'Cascadia Code', monospace;
      font-size: 0.8rem;
      line-height: 1.3;
      background: #1e293b;
      color: #e2e8f0;
      padding: 1.5rem;
      border-radius: 8px;
      overflow-x: auto;
    }
    footer {
      text-align: center;
      padding: 2rem;
      color: var(--text-light);
      font-size: 0.9rem;
    }
    @media (max-width: 768px) {
      .container { padding: 1rem; }
      section { padding: 1.5rem; }
      header { padding: 2rem 1rem; }
      header h1 { font-size: 1.75rem; }
      nav ul { gap: 0.25rem 1rem; }
    }
  </style>
</head>
<body>

<header>
  <h1>ThermalSim KiCad Plugin</h1>
  <p>Umfassender Code-Review und Technische Dokumentation</p>
</header>

<nav>
  <ul>
    <li><a href="#summary">Executive Summary</a></li>
    <li><a href="#architecture">Architektur</a></li>
    <li><a href="#physics">Physik</a></li>
    <li><a href="#numerics">Numerik</a></li>
    <li><a href="#quality">Code-Qualität</a></li>
    <li><a href="#limitations">Limitierungen</a></li>
    <li><a href="#validation">Validierung</a></li>
    <li><a href="#best-practices">Best Practices</a></li>
    <li><a href="#recommendations">Empfehlungen</a></li>
    <li><a href="#reference">Referenz</a></li>
  </ul>
</nav>

<div class="container">

<!-- 1. EXECUTIVE SUMMARY -->
<section id="summary">
  <h2>1. Executive Summary</h2>

  <div class="highlight-box">
    <strong>ThermalSim</strong> ist ein KiCad Action Plugin für transiente 2.5D-Wärmesimulation von Leiterplatten.
    Es ermöglicht PCB-Designern, thermische Hotspots direkt in KiCad zu identifizieren, ohne externe CAE-Software zu benötigen.
  </div>

  <h3>Hauptfunktionen</h3>
  <ul>
    <li><strong>Multilayer-Simulation:</strong> Unterstützt beliebige Anzahl von Kupferlagen mit realistischem Stackup</li>
    <li><strong>Transiente Analyse:</strong> Zeitabhängige Simulation mit BDF2-Zeitintegration</li>
    <li><strong>Automatische Geometrieerkennung:</strong> Extrahiert Kupferflächen, Vias und Zonen direkt aus dem PCB-Design</li>
    <li><strong>Heatsink-Modellierung:</strong> Optionale Thermal-Pad-Simulation über User.Eco1 Layer</li>
    <li><strong>Interaktive Vorschau:</strong> Visualisierung der erkannten Geometrie vor der Simulation</li>
    <li><strong>HTML-Report:</strong> Automatische Berichtsgenerierung mit Ergebnisbildern</li>
  </ul>

  <h3>Gesamtbewertung</h3>
  <div class="grid-2">
    <div class="metric-card">
      <h4>Funktionalität</h4>
      <div class="metric-value">★★★★☆</div>
      <p style="margin:0.5rem 0 0 0;font-size:0.9rem;">Solide Implementierung der thermischen Physik</p>
    </div>
    <div class="metric-card">
      <h4>Code-Struktur</h4>
      <div class="metric-value">★★★☆☆</div>
      <p style="margin:0.5rem 0 0 0;font-size:0.9rem;">Funktional, aber Modularisierung empfohlen</p>
    </div>
    <div class="metric-card">
      <h4>Benutzerfreundlichkeit</h4>
      <div class="metric-value">★★★★☆</div>
      <p style="margin:0.5rem 0 0 0;font-size:0.9rem;">Intuitive GUI mit guter Parametrisierung</p>
    </div>
    <div class="metric-card">
      <h4>Performance</h4>
      <div class="metric-value">★★★★☆</div>
      <p style="margin:0.5rem 0 0 0;font-size:0.9rem;">Effizient dank Sparse-Matrizen und LU-Zerlegung</p>
    </div>
  </div>

  <h3>Technische Eckdaten</h3>
  <table>
    <tr><th>Eigenschaft</th><th>Wert</th></tr>
    <tr><td>Codezeilen</td><td>~2087 (thermal_plugin.py)</td></tr>
    <tr><td>Hauptklassen</td><td>SettingsDialog, ThermalPlugin</td></tr>
    <tr><td>Numerische Methode</td><td>2.5D FVM mit impliziter BDF2-Zeitintegration</td></tr>
    <tr><td>Max. Knotenzahl</td><td>200.000 (konfigurierbar)</td></tr>
    <tr><td>Abhängigkeiten</td><td>numpy, scipy, matplotlib, wxPython, pcbnew</td></tr>
  </table>
</section>

<!-- 2. ARCHITEKTUR-ÜBERSICHT -->
<section id="architecture">
  <h2>2. Architektur-Übersicht</h2>

  <h3>Dateistruktur</h3>
  <pre><code>ThermalSim/
├── thermal_plugin.py          # Hauptmodul (2087 Zeilen)
├── __init__.py                # Plugin-Registrierung
├── thermal_sim_last_settings.json  # Persistierte Einstellungen
└── [Ausgabe-Ordner]/
    ├── thermal_report.html    # Simulationsbericht
    ├── thermal_preview.png    # Geometrie-Vorschau
    ├── thermal_final.png      # Endergebnis (2-Layer-Ansicht)
    ├── thermal_stackup.png    # Alle Lagen
    └── snap_*.png             # Zeitliche Snapshots</code></pre>

  <h3>Klassenstruktur</h3>
  <div class="ascii-diagram">
┌─────────────────────────────────────────────────────────────────────┐
│                        thermal_plugin.py                            │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ┌─────────────────────┐      ┌──────────────────────────────────┐ │
│  │   SettingsDialog    │      │        ThermalPlugin             │ │
│  │   (wx.Dialog)       │      │   (pcbnew.ActionPlugin)          │ │
│  ├─────────────────────┤      ├──────────────────────────────────┤ │
│  │ - power_input       │      │ - board, copper_ids, bbox        │ │
│  │ - time_input        │      │ - pads_list                      │ │
│  │ - res_input         │      ├──────────────────────────────────┤ │
│  │ - chk_all_layers    │◄────►│ + Run()                          │ │
│  │ - chk_heatsink      │      │ + RunSafe()                      │ │
│  ├─────────────────────┤      │ + create_multilayer_maps()       │ │
│  │ + get_values()      │      │ + get_pad_pixels()               │ │
│  │ + on_preview()      │      │ + build_pad_distance_mask()      │ │
│  │ + _apply_defaults() │      │ + save_snapshot()                │ │
│  └─────────────────────┘      │ + show_results_all_layers()      │ │
│                               │ + _write_html_report()           │ │
│  Standalone Funktionen:       │ + _derive_stackup_thicknesses()  │ │
│  ─────────────────────────    │ + generate_preview()             │ │
│  parse_stackup_from_board_    └──────────────────────────────────┘ │
│  format_stackup_report_um()                                        │
│  _sexpr_extract_block()                                            │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
  </div>

  <h3>Datenfluss</h3>
  <div class="ascii-diagram">
┌──────────┐    ┌──────────────┐    ┌─────────────┐    ┌───────────┐
│  KiCad   │───►│ Stackup-     │───►│ Geometrie-  │───►│ Sparse-   │
│  Board   │    │ Parser       │    │ Mapping     │    │ Matrix K  │
└──────────┘    └──────────────┘    └─────────────┘    └───────────┘
     │                                     │                  │
     ▼                                     ▼                  ▼
┌──────────┐    ┌──────────────┐    ┌─────────────┐    ┌───────────┐
│ Selected │───►│ Power        │───►│ Source-     │───►│ BDF2      │
│ Pads     │    │ Injection    │    │ Vektor Q    │    │ Solver    │
└──────────┘    └──────────────┘    └─────────────┘    └───────────┘
                                                             │
                                                             ▼
                                    ┌─────────────┐    ┌───────────┐
                                    │ HTML        │◄───│ Temperatur│
                                    │ Report      │    │ Feld T    │
                                    └─────────────┘    └───────────┘
  </div>

  <h3>Abhängigkeiten</h3>
  <table>
    <tr><th>Bibliothek</th><th>Verwendung</th><th>Version</th></tr>
    <tr><td><code>numpy</code></td><td>Array-Operationen, Lineare Algebra</td><td>≥1.20</td></tr>
    <tr><td><code>scipy.sparse</code></td><td>Sparse-Matrizen (COO, CSR, CSC)</td><td>≥1.7</td></tr>
    <tr><td><code>scipy.sparse.linalg</code></td><td>LU-Zerlegung (splu)</td><td>≥1.7</td></tr>
    <tr><td><code>matplotlib</code></td><td>Visualisierung (Heatmaps, Contours)</td><td>≥3.5</td></tr>
    <tr><td><code>wxPython</code></td><td>GUI (Dialog, ProgressDialog)</td><td>≥4.1</td></tr>
    <tr><td><code>pcbnew</code></td><td>KiCad Python-API</td><td>KiCad 8/9</td></tr>
    <tr><td><code>pypardiso</code></td><td>Optional: Intel MKL PARDISO Solver</td><td>Optional</td></tr>
    <tr><td><code>numba</code></td><td>Optional: JIT-Kompilierung (erkannt, nicht aktiv genutzt)</td><td>Optional</td></tr>
  </table>

  <h3>Integration mit KiCad</h3>
  <p>Das Plugin integriert sich als <code>ActionPlugin</code> in KiCads Plugin-System:</p>
  <pre><code class="python"># Zeile 464-470
class ThermalPlugin(pcbnew.ActionPlugin):
    def defaults(self):
        self.name = "2.5D Thermal Sim"
        self.category = "Simulation"
        self.description = "Crash-safe Multilayer Sim"
        self.show_toolbar_button = True</code></pre>

  <p>Der Zugriff auf Board-Daten erfolgt über die pcbnew-API:</p>
  <ul>
    <li><code>pcbnew.GetBoard()</code> - Aktives Board</li>
    <li><code>board.Footprints()</code> / <code>board.Pads()</code> - Bauteile und Pads</li>
    <li><code>board.Tracks()</code> - Leiterbahnen und Vias</li>
    <li><code>board.Zones()</code> - Kupferflächen</li>
    <li><code>zone.HitTestFilledArea()</code> - Pixel-genaue Zonenerkennung (KiCad 9)</li>
  </ul>
</section>

<!-- 3. PHYSIKALISCHE GRUNDLAGEN -->
<section id="physics">
  <h2>3. Physikalische Grundlagen</h2>

  <h3>Wärmeleitungsgleichung</h3>
  <p>Das Plugin löst die instationäre Wärmeleitungsgleichung in 2.5D:</p>

  <div class="equation">
    ρ·c<sub>p</sub> · ∂T/∂t = ∇·(k·∇T) + q̇
  </div>

  <p>Wobei:</p>
  <ul>
    <li><strong>ρ</strong> = Dichte [kg/m³]</li>
    <li><strong>c<sub>p</sub></strong> = Spezifische Wärmekapazität [J/(kg·K)]</li>
    <li><strong>k</strong> = Wärmeleitfähigkeit [W/(m·K)]</li>
    <li><strong>q̇</strong> = Volumetrische Wärmequelle [W/m³]</li>
  </ul>

  <h3>2.5D Finite-Volumen-Methode (FVM)</h3>
  <p>Die Diskretisierung erfolgt auf einem regelmäßigen 2D-Gitter pro Kupferlage mit thermischer Kopplung zwischen den Lagen:</p>

  <div class="ascii-diagram">
                    Konvektion (h_top = 10 W/m²K)
                           ↑ ↑ ↑ ↑ ↑
    ┌──────────────────────────────────────────────┐
    │            F.Cu (Top Layer)                  │  ← In-Plane: k_Cu
    ├──────────────────────────────────────────────┤
    │            Prepreg (FR4)                     │  ← Vertikal: k_FR4/gap
    ├──────────────────────────────────────────────┤
    │            In1.Cu                            │  ← Enhanced durch Vias
    ├──────────────────────────────────────────────┤
    │            Core (FR4)                        │
    ├──────────────────────────────────────────────┤
    │            In2.Cu                            │
    ├──────────────────────────────────────────────┤
    │            Prepreg (FR4)                     │
    ├──────────────────────────────────────────────┤
    │            B.Cu (Bottom Layer)               │
    └──────────────────────────────────────────────┘
                           ↓ ↓ ↓ ↓ ↓
                    Konvektion / Heatsink
  </div>

  <h3>Wärmeübertragungsmechanismen</h3>

  <h4>In-Plane Wärmeleitung</h4>
  <p>Die laterale Wärmeleitung innerhalb jeder Lage wird über harmonisch gemittelte Leitfähigkeiten berechnet:</p>
  <pre><code># Zeile 835-836: Horizontale Kopplung
k_h = 2.0 * k_layer[:, :-1] * k_layer[:, 1:] / (k_layer[:, :-1] + k_layer[:, 1:] + eps)
Gx = k_h * (t_edge * dy) / dx</code></pre>

  <h4>Vertikale Kopplung zwischen Lagen</h4>
  <p>Die thermische Kopplung zwischen Kupferlagen erfolgt durch das FR4-Dielektrikum, verstärkt durch Vias:</p>
  <pre><code># Zeile 863-874: Vertikale Kopplung mit Via-Enhancement
V_enh = np.clip(V_map, 1.0, 50.0)
for l in range(layer_count - 1):
    gap_val = max(gap_m[l], 1e-6)
    Gz_base = k_fr4 * pixel_area / gap_val
    Gz = (Gz_base * V_enh).ravel()</code></pre>

  <h4>Konvektion an Oberflächen</h4>
  <p>Robin-Randbedingungen für natürliche Konvektion:</p>
  <pre><code># Zeile 885-901: Konvektive Randbedingungen
h_top = 10.0  # W/m²K (obere Fläche)
h_air_bot = 10.0  # W/m²K (untere Fläche ohne Heatsink)

# Mit Heatsink: effektiver h-Wert
h_sink = (pad_k / pad_thick_m) * contact_factor
h_bot_eff = (1.0 - H_map) * h_air_bot + H_map * h_sink</code></pre>

  <h3>Materialparameter</h3>
  <table>
    <tr><th>Material</th><th>k [W/(m·K)]</th><th>ρ [kg/m³]</th><th>c<sub>p</sub> [J/(kg·K)]</th><th>Quelle im Code</th></tr>
    <tr><td>Kupfer (Cu)</td><td>390</td><td>8960</td><td>385</td><td>Zeile 729-730</td></tr>
    <tr><td>FR4 Epoxid</td><td>0.3</td><td>1850</td><td>1100</td><td>Zeile 731</td></tr>
    <tr><td>Via-Faktor</td><td colspan="3">k_Cu / k_FR4 = 1300</td><td>Zeile 696</td></tr>
  </table>

  <h3>Thermische Kapazität</h3>
  <p>Die volumetrische Wärmekapazität wird für jeden Knoten berechnet:</p>
  <pre><code># Zeile 755-771: Kapazitätsberechnung pro Zelle
V_cu = pixel_area * t_cu[l]
V_fr4 = pixel_area * t_fr4_eff[l]
C_layer = np.where(mask, rho_cu * cp_cu * V_cu, rho_fr4 * cp_fr4 * V_fr4)
# Dielektrikum unter Kupfer zusätzlich berücksichtigt
C_layer += mask * (rho_fr4 * cp_fr4 * V_fr4 * dielectric_under_copper_factor)</code></pre>

  <h3>Energiebilanz-Monitoring</h3>
  <p>Das Plugin überwacht die Energiebilanz zur Qualitätssicherung:</p>
  <div class="equation">
    ΔE = ∫(P<sub>in</sub> - P<sub>out</sub>) dt
  </div>
  <pre><code># Zeile 1000-1014: Energiebilanz-Check
energy = float(np.sum(C * delta_t))
dE = energy - e0
eps_abs = abs(dE - balance_integral)
eps_rel = eps_abs / max(abs(t_elapsed * pin), 1e-9)
balance_warn = eps_rel > 0.01 or eps_abs > 0.01</code></pre>
</section>

<!-- 4. NUMERISCHE METHODEN -->
<section id="numerics">
  <h2>4. Numerische Methoden</h2>

  <h3>Zeitintegration: BDF2-Schema</h3>
  <p>Das Plugin verwendet ein zweistufiges implizites Verfahren:</p>

  <h4>1. Erster Zeitschritt: Backward Euler (BE)</h4>
  <div class="equation">
    (C/Δt + K) · T<sup>n+1</sup> = (C/Δt) · T<sup>n</sup> + Q + b
  </div>

  <h4>2. Folgende Zeitschritte: BDF2</h4>
  <div class="equation">
    (1.5·C/Δt + K) · T<sup>n+1</sup> = (2·C/Δt) · T<sup>n</sup> - (0.5·C/Δt) · T<sup>n-1</sup> + Q + b
  </div>

  <pre><code># Zeile 1052-1053: Matrix-Assembly für BE und BDF2
A_be = K + sp.diags(D, format="csr")      # BE-Matrix
A_bdf2 = K + sp.diags(1.5 * D, format="csr")  # BDF2-Matrix

# Zeile 1088-1089: BE-Schritt
rhs1 = D * Tn + Q + b
solve_elapsed = _advance_step(rhs1, solve_be, phase_dt)

# Zeile 1108: BDF2-Schritte
rhs = (2.0 * D) * Tn - (0.5 * D) * Tnm1 + Q + b</code></pre>

  <h3>Sparse-Matrix Assembly</h3>
  <p>Die Steifigkeitsmatrix K wird im COO-Format assembliert und in CSR konvertiert:</p>

  <div class="ascii-diagram">
Matrix K (N × N, N = rows × cols × layers):

     ┌─────────────────────────────────────────────┐
     │ Diag: In-plane + Conv  │ Off-diag: Layer 1 │
     │ ──────────────────────────────────────────  │
     │ Off-diag: Layer 1     │ Diag: Layer 2      │
     │ ──────────────────────────────────────────  │
     │ Off-diag: Layer 2     │ ... vertikale Koppl│
     └─────────────────────────────────────────────┘

Struktur pro Layer (RC × RC):
- 5-Punkt-Stern für In-Plane (horizontal + vertikal)
- Diagonaleinträge für Konvektion
  </div>

  <pre><code># Zeile 876-880: COO-Matrix Assembly
K_base = sp.coo_matrix(
    (np.concatenate(data_list),
     (np.concatenate(rows_list), np.concatenate(cols_list))),
    shape=(N, N),
    dtype=np.float64
).tocsr()</code></pre>

  <h3>LU-Zerlegung</h3>
  <p>Die Matrix wird nur einmal pro Phase faktorisiert (effizient für konstante Δt):</p>
  <pre><code># Zeile 1064-1067: SciPy SuperLU
lu_be = spla.splu(A_be.tocsc())
lu_bdf2 = spla.splu(A_bdf2.tocsc())
solve_be = lu_be.solve
solve_bdf2 = lu_bdf2.solve

# Optional: Intel MKL PARDISO (Zeile 1057-1062)
if use_pardiso and hasattr(pypardiso, "factorized"):
    solve_be = pypardiso.factorized(A_be.tocsc())
    solve_bdf2 = pypardiso.factorized(A_bdf2.tocsc())</code></pre>

  <h3>Multi-Phasen Zeitschritt-Strategie</h3>
  <p>Um sowohl schnelle Anfangstransienten als auch den stationären Zustand effizient zu erfassen:</p>
  <table>
    <tr><th>Phase</th><th>Anteil</th><th>Δt-Skalierung</th><th>Zweck</th></tr>
    <tr><td>A</td><td>8%</td><td>0.5×</td><td>Schnelle Transienten</td></tr>
    <tr><td>B</td><td>35%</td><td>1.0×</td><td>Übergangsbereich</td></tr>
    <tr><td>C</td><td>57%</td><td>2.0×</td><td>Quasi-stationär</td></tr>
  </table>

  <pre><code># Zeile 969-976: Phasen-Definition
phase_defs = [
    {"name": "A", "frac": 0.08, "dt_scale": 0.5},
    {"name": "B", "frac": 0.35, "dt_scale": 1.0},
    {"name": "C", "frac": 0.57, "dt_scale": 2.0},
]</code></pre>

  <h3>Konvergenz und Stabilität</h3>
  <div class="highlight-box">
    <strong>Implizites Verfahren:</strong> Die BDF2-Methode ist unbedingt stabil (A-stabil),
    daher gibt es keine CFL-ähnliche Zeitschrittbeschränkung. Die Zeitschrittgröße wird
    nur durch Genauigkeitsanforderungen limitiert.
  </div>

  <p>Adaptive Zeitschrittberechnung basierend auf Simulationszeit:</p>
  <pre><code># Zeile 717-722: Zeitschrittberechnung
steps_target = _clamp(int(120 * (sim_time ** 0.35)), 80, 600)
dt = sim_time / steps_target</code></pre>
</section>

<!-- 5. CODE-QUALITÄT REVIEW -->
<section id="quality">
  <h2>5. Code-Qualität Review</h2>

  <h3>Stärken</h3>

  <h4>Robuste Fehlerbehandlung</h4>
  <p>Das Plugin ist "crash-safe" durch umfassende Exception-Handling:</p>
  <pre><code># Zeile 496-501: Top-Level Error Handling
def Run(self):
    try:
        self.RunSafe()
    except Exception:
        wx.MessageBox(traceback.format_exc(), "Thermal Sim Error")</code></pre>

  <h4>Settings-Persistenz</h4>
  <p>Benutzereinstellungen werden zwischen Sessions gespeichert:</p>
  <pre><code># Zeile 478-494: JSON-basierte Settings
def _settings_path(self):
    return os.path.join(os.path.dirname(__file__),
                        "thermal_sim_last_settings.json")

def _load_settings(self):
    try:
        with open(self._settings_path(), "r", encoding="utf-8") as f:
            return json.load(f)
    except Exception:
        return {}</code></pre>

  <h4>Flexible Ausgabeoptionen</h4>
  <ul>
    <li>Wählbarer Ausgabeordner mit automatischem Timestamp</li>
    <li>Optionale Zeitreihen-Snapshots</li>
    <li>HTML-Report mit eingebetteten Bildern</li>
    <li>Separate Top/Bottom oder All-Layers Ansicht</li>
  </ul>

  <h4>KiCad 8/9 Kompatibilität</h4>
  <p>Das Plugin behandelt API-Unterschiede zwischen KiCad-Versionen:</p>
  <pre><code># Zeile 1371-1395: Fallback für ältere KiCad-Versionen
has_filled_hit = hasattr(zone, "HitTestFilledArea")
# ...
if has_filled_hit:
    hit = zone.HitTestFilledArea(lid, pos, margin_iu)
elif hasattr(zone, "HitTest"):
    hit = zone.HitTest(pos)</code></pre>

  <h3>Verbesserungspotenzial</h3>

  <h4>Modularisierung</h4>
  <div class="warning-box">
    <strong>Problem:</strong> Alle 2087 Zeilen befinden sich in einer einzigen Datei.<br>
    <strong>Empfehlung:</strong> Aufteilung in Module:
    <ul style="margin:0.5rem 0 0 0;">
      <li><code>thermal_solver.py</code> - Numerischer Kern</li>
      <li><code>geometry_mapper.py</code> - PCB-Geometrie-Extraktion</li>
      <li><code>visualization.py</code> - Matplotlib-Plots</li>
      <li><code>ui_dialog.py</code> - wxPython GUI</li>
      <li><code>stackup_parser.py</code> - .kicad_pcb Parsing</li>
    </ul>
  </div>

  <h4>Dokumentation</h4>
  <div class="warning-box">
    <strong>Problem:</strong> Wenige Docstrings, keine Type Hints.<br>
    <strong>Beispiel fehlender Dokumentation (Zeile 1277):</strong>
    <pre style="margin:0.5rem 0 0 0;"><code>def create_multilayer_maps(self, board, copper_ids, rows, cols,
                           x_min, y_min, res, settings, k_fr4,
                           k_cu_layers, via_factor, pads_list):
    # Keine Docstring, keine Type Hints
    num_layers = len(copper_ids)
    ...</code></pre>
  </div>

  <h4>Unit-Tests</h4>
  <div class="warning-box">
    <strong>Problem:</strong> Keine automatisierten Tests vorhanden.<br>
    <strong>Empfehlung:</strong> Pytest-Suite für:
    <ul style="margin:0.5rem 0 0 0;">
      <li>Stackup-Parser (unabhängig von KiCad)</li>
      <li>Numerischer Solver (mit synthetischen Daten)</li>
      <li>Energiebilanz-Validierung</li>
    </ul>
  </div>

  <h3>Code-Metriken</h3>
  <div class="grid-2">
    <div class="metric-card">
      <h4>Gesamtzeilen</h4>
      <div class="metric-value">2087</div>
    </div>
    <div class="metric-card">
      <h4>Klassen</h4>
      <div class="metric-value">2</div>
    </div>
    <div class="metric-card">
      <h4>Funktionen (Modul)</h4>
      <div class="metric-value">5</div>
    </div>
    <div class="metric-card">
      <h4>Methoden (ThermalPlugin)</h4>
      <div class="metric-value">15</div>
    </div>
  </div>

  <h4>Längste Methoden</h4>
  <table>
    <tr><th>Methode</th><th>Zeilen</th><th>Bemerkung</th></tr>
    <tr><td><code>RunSafe()</code></td><td>~780</td><td><span class="badge badge-warning">Zu lang - Refactoring empfohlen</span></td></tr>
    <tr><td><code>create_multilayer_maps()</code></td><td>~225</td><td><span class="badge badge-warning">Komplex</span></td></tr>
    <tr><td><code>_write_html_report()</code></td><td>~180</td><td><span class="badge badge-info">OK - Template-Generierung</span></td></tr>
    <tr><td><code>_save_preview_image()</code></td><td>~130</td><td><span class="badge badge-success">Akzeptabel</span></td></tr>
  </table>
</section>

<!-- 6. LIMITIERUNGEN & ANNAHMEN -->
<section id="limitations">
  <h2>6. Limitierungen & Annahmen</h2>

  <h3>Physikalische Vereinfachungen</h3>
  <table>
    <tr><th>Vereinfachung</th><th>Auswirkung</th><th>Empfohlene Anwendung</th></tr>
    <tr>
      <td><strong>Keine Strahlungswärme</strong></td>
      <td>Unterschätzt Wärmeabfuhr bei T > 100°C</td>
      <td>T < 150°C, Indoor-Anwendungen</td>
    </tr>
    <tr>
      <td><strong>Konstante Konvektionskoeffizienten</strong></td>
      <td>h = 10 W/m²K (natürliche Konvektion)</td>
      <td>Ruhende Luft, keine Zwangskühlung</td>
    </tr>
    <tr>
      <td><strong>Keine Bauteil-Package-Modelle</strong></td>
      <td>Wärme wird direkt am Pad injiziert</td>
      <td>SMD-Bauteile mit direktem Pad-Kontakt</td>
    </tr>
    <tr>
      <td><strong>Temperaturunabhängige Eigenschaften</strong></td>
      <td>k, ρ, c<sub>p</sub> sind Konstanten</td>
      <td>Moderater Temperaturbereich (25-125°C)</td>
    </tr>
    <tr>
      <td><strong>Keine Phasenübergänge</strong></td>
      <td>Kein Schmelzen von Lötzinn</td>
      <td>T < 183°C (eutek. Sn/Pb)</td>
    </tr>
  </table>

  <h3>Geometrische Vereinfachungen</h3>

  <h4>Rasterbasierte Diskretisierung</h4>
  <div class="warning-box">
    <strong>Einschränkung:</strong> Schräge Leiterbahnen und Kreisgeometrien werden
    durch rechteckige Pixel approximiert. Die Auflösung bestimmt die Genauigkeit.
    <p style="margin:0.5rem 0 0 0;"><strong>Typische Auflösung:</strong> 0.2 - 1.0 mm</p>
  </div>

  <h4>Via-Enhancement als Heuristik</h4>
  <p>Vias werden nicht als explizite 3D-Zylinder modelliert, sondern erhöhen den
  lokalen vertikalen Wärmeleitwert:</p>
  <pre><code># Zeile 696: Via-Faktor = k_Cu / k_FR4
via_factor = 390.0 / 0.3  # ≈ 1300

# Anwendung (Zeile 1420-1421):
if is_via:
    fill_via(t.GetBoundingBox(), via_factor)</code></pre>

  <h4>Adiabatische Seitenränder</h4>
  <p>An den Kanten der simulierten Region wird kein Wärmefluss angenommen (∂T/∂n = 0).
  Dies kann bei begrenzten Simulationsgebieten ("Limit Area to Pads") zu Fehlern führen.</p>

  <h3>Numerische Limits</h3>
  <table>
    <tr><th>Parameter</th><th>Limit</th><th>Begründung</th></tr>
    <tr>
      <td>Max. Knotenzahl</td>
      <td>200.000</td>
      <td>Speicher- und Rechenzeit (Zeile 657)</td>
    </tr>
    <tr>
      <td>h (oben/unten)</td>
      <td>10 W/m²K (fest)</td>
      <td>Natürliche Konvektion (Zeile 885, 891)</td>
    </tr>
    <tr>
      <td>Via-Enhancement</td>
      <td>max. 50×</td>
      <td>Numerische Stabilität (Zeile 864)</td>
    </tr>
    <tr>
      <td>Zeitschritte</td>
      <td>80 - 600</td>
      <td>Balance Genauigkeit/Performance (Zeile 720)</td>
    </tr>
    <tr>
      <td>Snapshot-Anzahl</td>
      <td>max. 50</td>
      <td>Speicherplatz (Zeile 919)</td>
    </tr>
  </table>

  <h3>Bekannte Einschränkungen bei der Geometrieerkennung</h3>
  <ul>
    <li><strong>Zones ohne Fill:</strong> Unfilled Zones werden übersprungen (Zeile 1438)</li>
    <li><strong>Rule Areas / Keepouts:</strong> Werden ignoriert, nicht als Wärmebarriere modelliert</li>
    <li><strong>Thermal Reliefs:</strong> Die Spoke-Geometrie wird nicht explizit erfasst</li>
    <li><strong>Solder Mask:</strong> Wird nicht als zusätzliche Isolationsschicht berücksichtigt</li>
  </ul>
</section>

<!-- 7. VALIDIERUNG & GENAUIGKEIT -->
<section id="validation">
  <h2>7. Validierung & Genauigkeit</h2>

  <h3>Interne Validierung</h3>
  <p>Das Plugin führt automatische Energiebilanz-Checks durch:</p>

  <div class="highlight-box">
    <strong>Energiebilanz-Kriterium:</strong><br>
    <code>eps_rel = |ΔE - ∫(P_in - P_out)dt| / (t · P_in) < 1%</code>
  </div>

  <pre><code># Zeile 1159-1168: Steady-State Check
if balance_history:
    recent = balance_history[-min(3, len(balance_history)):]
    steady_ok = all(
        abs(item["dE"]) / max(abs(item["delta_t"] * pin), 1e-9) < 0.01
        for item in recent
    )
if steady_ok:
    rel_diff = abs(pin - pout_final) / max(abs(pin), 1e-9)</code></pre>

  <h3>Erwartete Genauigkeit vs. Vollständige 3D-FEM</h3>
  <table>
    <tr><th>Szenario</th><th>2.5D ThermalSim</th><th>3D FEM</th><th>Abweichung</th></tr>
    <tr>
      <td>Einfaches 2-Layer Board, zentraler Hotspot</td>
      <td>Gut</td>
      <td>Referenz</td>
      <td>5-10%</td>
    </tr>
    <tr>
      <td>4+ Lagen mit Via-Arrays</td>
      <td>Moderat</td>
      <td>Referenz</td>
      <td>10-20%</td>
    </tr>
    <tr>
      <td>Komplexe BGA mit Thermal Vias</td>
      <td>Grob</td>
      <td>Referenz</td>
      <td>15-30%</td>
    </tr>
    <tr>
      <td>Hohe Leistungsdichte (>100 W/cm²)</td>
      <td>Eingeschränkt</td>
      <td>Referenz</td>
      <td>>25%</td>
    </tr>
  </table>

  <h3>Empfohlene Anwendungsfälle</h3>
  <div class="grid-2">
    <div style="background:#dcfce7;padding:1rem;border-radius:8px;">
      <h4 style="color:#166534;margin:0 0 0.5rem 0;">✓ Gut geeignet</h4>
      <ul style="margin:0;color:#166534;">
        <li>Frühe Design-Phase: Hotspot-Identifikation</li>
        <li>Vergleich von Layout-Varianten</li>
        <li>Dimensionierung von Kupferflächen</li>
        <li>Via-Placement Optimierung</li>
        <li>Thermal Pad Sizing</li>
      </ul>
    </div>
    <div style="background:#fee2e2;padding:1rem;border-radius:8px;">
      <h4 style="color:#991b1b;margin:0 0 0.5rem 0;">✗ Nicht geeignet</h4>
      <ul style="margin:0;color:#991b1b;">
        <li>Präzise Junction-Temperatur-Vorhersage</li>
        <li>Zertifizierungsnachweis</li>
        <li>Hochleistungs-GaN/SiC Designs</li>
        <li>Thermomechanische Spannungsanalyse</li>
        <li>Designs mit erzwungener Kühlung</li>
      </ul>
    </div>
  </div>
</section>

<!-- 8. BEST PRACTICES: KICAD PLUGIN-ENTWICKLUNG MIT CLAUDE CODE -->
<section id="best-practices">
  <h2>8. Best Practices: KiCad Plugin-Entwicklung mit Claude Code</h2>

  <h3>Iterative Entwicklung</h3>
  <p>Die Entwicklung von ThermalSim demonstriert einen effektiven iterativen Workflow:</p>

  <div class="ascii-diagram">
┌───────────┐    ┌────────────┐    ┌──────────┐    ┌───────────┐
│  Anforder-│───►│  Claude    │───►│  Test in │───►│  Feedback │
│  ung      │    │  Code      │    │  KiCad   │    │  & Refine │
└───────────┘    └────────────┘    └──────────┘    └───────────┘
      ▲                                                   │
      └───────────────────────────────────────────────────┘
  </div>

  <h3>Tipps für effektive Prompts</h3>

  <h4>1. Klare Problemdefinition</h4>
  <pre><code># Gut:
"Implementiere eine Funktion, die alle Vias im Board findet und
deren Bounding Box als (x, y, w, h) in mm zurückgibt."

# Weniger gut:
"Mach was mit Vias."</code></pre>

  <h4>2. Kontext aus vorhandenem Code</h4>
  <pre><code># Gut:
"In der Methode create_multilayer_maps() (Zeile 1277) wird aktuell
fill_box() für Kupfer verwendet. Füge eine ähnliche Funktion für
Zones hinzu, die HitTestFilledArea() nutzt."</code></pre>

  <h4>3. Fehlermeldungen vollständig teilen</h4>
  <pre><code># Gut:
"Beim Ausführen in KiCad erhalte ich:
  File 'thermal_plugin.py', line 1393
  AttributeError: 'ZONE' object has no attribute 'HitTestFilledArea'
Das passiert bei KiCad 8.0.2 auf Windows."</code></pre>

  <h3>Debugging-Strategien</h3>

  <h4>Console Output in KiCad</h4>
  <pre><code># Debugging mit print() - Output in KiCad Scripting Console
print(f"[ThermalSim] layers={copper_ids}, res={res}mm")
print(f"[ThermalSim][EnergyBalance] Pin={pin:.6f}W Pout={pout_step:.6f}W")</code></pre>

  <h4>Separate Test-Skripte</h4>
  <pre><code># test_stackup_parser.py - Unabhängig von KiCad testbar
from thermal_plugin import parse_stackup_from_board_file

class MockBoard:
    def GetFileName(self): return "test.kicad_pcb"
    def GetLayerID(self, name): return {"F.Cu": 0, "B.Cu": 31}[name]

result = parse_stackup_from_board_file(MockBoard())
assert "copper" in result</code></pre>

  <h3>Versionskontrolle und Backup</h3>
  <div class="highlight-box">
    <strong>Empfehlung:</strong> Vor jeder größeren Änderung einen Git-Commit erstellen.
    <pre style="margin:0.5rem 0 0 0;"><code>git add thermal_plugin.py
git commit -m "Add zone hit-test for filled areas"</code></pre>
  </div>

  <h3>Testing ohne GUI (Headless-Modus)</h3>
  <p>Für automatisierte Tests kann der numerische Kern isoliert werden:</p>
  <pre><code># Beispiel: Solver-Test ohne wxPython/KiCad
import numpy as np
import scipy.sparse as sp
import scipy.sparse.linalg as spla

# Synthetisches 2D-Wärmeleitungsproblem
N = 100
K = sp.diags([-1, 4, -1], [-1, 0, 1], shape=(N, N), format="csr")
Q = np.zeros(N)
Q[N//2] = 1.0  # Wärmequelle in der Mitte

# Stationäre Lösung
T = spla.spsolve(K, Q)
assert T[N//2] > T[0]  # Mitte wärmer als Rand</code></pre>

  <h3>Dokumentation automatisch generieren</h3>
  <p>Claude Code kann bei der Erstellung von Docstrings helfen:</p>
  <pre><code># Prompt:
"Generiere NumPy-Style Docstrings für die Methode create_multilayer_maps()"

# Ergebnis:
def create_multilayer_maps(self, board, copper_ids, rows, cols,
                           x_min, y_min, res, settings, k_fr4,
                           k_cu_layers, via_factor, pads_list):
    """
    Erstellt thermische Eigenschafts-Maps für alle Kupferlagen.

    Parameters
    ----------
    board : pcbnew.BOARD
        KiCad Board-Objekt
    copper_ids : list of int
        Layer-IDs der Kupferlagen in Stackup-Reihenfolge
    rows, cols : int
        Gitterdimensionen
    ...

    Returns
    -------
    K : ndarray (layers, rows, cols)
        Relative Wärmeleitfähigkeits-Map
    V_map : ndarray (rows, cols)
        Via-Enhancement-Faktoren
    H_map : ndarray (rows, cols)
        Heatsink-Maske (0 oder 1)
    """</code></pre>
</section>

<!-- 9. EMPFEHLUNGEN FÜR WEITERENTWICKLUNG -->
<section id="recommendations">
  <h2>9. Empfehlungen für Weiterentwicklung</h2>

  <h3>Mögliche Erweiterungen</h3>
  <table>
    <tr><th>Feature</th><th>Aufwand</th><th>Nutzen</th></tr>
    <tr>
      <td>Erzwungene Konvektion (variabler h-Wert)</td>
      <td><span class="badge badge-success">Niedrig</span></td>
      <td><span class="badge badge-info">Hoch</span></td>
    </tr>
    <tr>
      <td>Import von Bauteil-Thermal-Modellen (.s2p)</td>
      <td><span class="badge badge-warning">Mittel</span></td>
      <td><span class="badge badge-info">Hoch</span></td>
    </tr>
    <tr>
      <td>Export nach CSV/JSON für externe Analyse</td>
      <td><span class="badge badge-success">Niedrig</span></td>
      <td><span class="badge badge-warning">Mittel</span></td>
    </tr>
    <tr>
      <td>Strahlungswärme (Stefan-Boltzmann)</td>
      <td><span class="badge badge-warning">Mittel</span></td>
      <td><span class="badge badge-warning">Mittel</span></td>
    </tr>
    <tr>
      <td>Temperaturabhängige Materialparameter</td>
      <td><span class="badge badge-error">Hoch</span></td>
      <td><span class="badge badge-warning">Mittel</span></td>
    </tr>
    <tr>
      <td>GPU-Beschleunigung (CuPy/CUDA)</td>
      <td><span class="badge badge-error">Hoch</span></td>
      <td><span class="badge badge-warning">Mittel</span></td>
    </tr>
  </table>

  <h3>Performance-Optimierungen</h3>
  <ul>
    <li><strong>Numba JIT:</strong> Die <code>HAS_NUMBA</code>-Flag ist bereits vorhanden (Zeile 237-240),
    aber nicht aktiv genutzt. Schleifen in <code>fill_zone()</code> sind gute Kandidaten.</li>
    <li><strong>Multiprocessing:</strong> Parallele Geometrie-Erkennung pro Layer.</li>
    <li><strong>Adaptive Mesh Refinement:</strong> Feineres Gitter nur in der Nähe von Wärmequellen.</li>
    <li><strong>Caching:</strong> Geometrie-Maps speichern, wenn sich das Board nicht ändert.</li>
  </ul>

  <h3>Verbesserung der physikalischen Modelle</h3>
  <ol>
    <li><strong>Thermal Via Modellierung:</strong>
      <ul>
        <li>Aktuell: Einfacher Multiplikator auf vertikale Leitfähigkeit</li>
        <li>Verbesserung: Explizite Via-Geometrie (Durchmesser, Barrel-Leitfähigkeit)</li>
      </ul>
    </li>
    <li><strong>Solder Mask:</strong>
      <ul>
        <li>Zusätzliche dünne Isolationsschicht (k ≈ 0.2 W/mK)</li>
        <li>Reduzierter Konvektionskoeffizient auf maskierten Flächen</li>
      </ul>
    </li>
    <li><strong>BGA/QFN Packages:</strong>
      <ul>
        <li>Mehrfache Wärmepfade: Die-Attach, Bonding Wires, Mold Compound</li>
        <li>Import von JEDEC-konformen Thermal Models</li>
      </ul>
    </li>
  </ol>
</section>

<!-- 10. TECHNISCHE REFERENZ -->
<section id="reference">
  <h2>10. Technische Referenz</h2>

  <h3>Wichtige Dateien und Zeilennummern</h3>
  <table>
    <tr><th>Komponente</th><th>Datei:Zeile</th><th>Beschreibung</th></tr>
    <tr><td>Plugin-Registrierung</td><td class="file-ref">thermal_plugin.py:464-470</td><td>ActionPlugin defaults()</td></tr>
    <tr><td>Stackup-Parser</td><td class="file-ref">thermal_plugin.py:78-206</td><td>parse_stackup_from_board_file()</td></tr>
    <tr><td>Dialog-GUI</td><td class="file-ref">thermal_plugin.py:242-462</td><td>SettingsDialog Klasse</td></tr>
    <tr><td>Hauptsimulation</td><td class="file-ref">thermal_plugin.py:503-1276</td><td>RunSafe() Methode</td></tr>
    <tr><td>Matrix-Assembly</td><td class="file-ref">thermal_plugin.py:819-880</td><td>Sparse K-Matrix</td></tr>
    <tr><td>BDF2-Solver</td><td class="file-ref">thermal_plugin.py:1047-1139</td><td>Zeitintegration</td></tr>
    <tr><td>Geometrie-Mapping</td><td class="file-ref">thermal_plugin.py:1277-1500</td><td>create_multilayer_maps()</td></tr>
    <tr><td>Visualisierung</td><td class="file-ref">thermal_plugin.py:1544-1720</td><td>Matplotlib Plots</td></tr>
    <tr><td>HTML-Report</td><td class="file-ref">thermal_plugin.py:1906-2087</td><td>_write_html_report()</td></tr>
  </table>

  <h3>Physikalische Konstanten im Code</h3>
  <table>
    <tr><th>Konstante</th><th>Wert</th><th>Zeile</th><th>Einheit</th></tr>
    <tr><td>k_Cu</td><td>390.0</td><td>729</td><td>W/(m·K)</td></tr>
    <tr><td>k_FR4</td><td>0.3</td><td>730</td><td>W/(m·K)</td></tr>
    <tr><td>ρ_Cu</td><td>8960.0</td><td>730</td><td>kg/m³</td></tr>
    <tr><td>c_p_Cu</td><td>385.0</td><td>730</td><td>J/(kg·K)</td></tr>
    <tr><td>ρ_FR4</td><td>1850.0</td><td>731</td><td>kg/m³</td></tr>
    <tr><td>c_p_FR4</td><td>1100.0</td><td>731</td><td>J/(kg·K)</td></tr>
    <tr><td>h_top</td><td>10.0</td><td>885</td><td>W/(m²·K)</td></tr>
    <tr><td>h_air_bottom</td><td>10.0</td><td>891</td><td>W/(m²·K)</td></tr>
    <tr><td>via_factor</td><td>1300.0</td><td>696</td><td>dimensionslos</td></tr>
    <tr><td>ref_cu_thick</td><td>35e-6</td><td>697</td><td>m (35 µm)</td></tr>
  </table>

  <h3>Konfigurationsparameter (GUI)</h3>
  <table>
    <tr><th>Parameter</th><th>Default</th><th>Bereich</th><th>Beschreibung</th></tr>
    <tr><td>Pad Power</td><td>1.0 W</td><td>>0</td><td>Wärmelast pro Pad (oder kommasepariert)</td></tr>
    <tr><td>Duration</td><td>20.0 s</td><td>>0</td><td>Simulationsdauer</td></tr>
    <tr><td>Ambient Temp</td><td>25.0 °C</td><td>-40 bis 125</td><td>Umgebungstemperatur</td></tr>
    <tr><td>PCB Thickness</td><td>1.6 mm</td><td>0.4 bis 3.2</td><td>Gesamtdicke (Fallback)</td></tr>
    <tr><td>Resolution</td><td>auto</td><td>0.2 bis 2.0</td><td>Gitterauflösung in mm</td></tr>
    <tr><td>Limit Distance</td><td>30 mm</td><td>>0</td><td>Radius um Pads für begrenzte Simulation</td></tr>
    <tr><td>Pad Thickness</td><td>1.0 mm</td><td>>0</td><td>Heatsink/Thermal-Pad Dicke</td></tr>
    <tr><td>Pad Cond.</td><td>3.0 W/(m·K)</td><td>>0</td><td>Heatsink Wärmeleitfähigkeit</td></tr>
    <tr><td>Pad Heat Cap.</td><td>0.0 J/(m²·K)</td><td>≥0</td><td>Zusätzliche areale Wärmekapazität</td></tr>
    <tr><td>Snapshots</td><td>5</td><td>1 bis 50</td><td>Anzahl der Zeitreihen-Bilder</td></tr>
  </table>

  <h3>Literaturverweise</h3>
  <ul>
    <li>Incropera, F. P. et al.: <em>Fundamentals of Heat and Mass Transfer</em>, 7th ed., Wiley, 2011.</li>
    <li>Ascher, U. M. & Petzold, L. R.: <em>Computer Methods for Ordinary Differential Equations</em>, SIAM, 1998. (BDF-Methoden)</li>
    <li>Davis, T. A.: <em>Direct Methods for Sparse Linear Systems</em>, SIAM, 2006. (LU-Zerlegung)</li>
    <li>KiCad Documentation: <em>Python Scripting Reference</em>, <a href="https://docs.kicad.org/master/en/python/pcbnew/">https://docs.kicad.org</a></li>
  </ul>
</section>

</div>

<footer>
  <p>ThermalSim Review-Report | Generiert am 31. Januar 2026</p>
  <p>Erstellt mit Claude Code für die Analyse von thermal_plugin.py (Version: 2087 Zeilen)</p>
</footer>

</body>
</html>
